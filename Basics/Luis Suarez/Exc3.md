# Waterfall

## Phases of Waterfall (Source https://www.lucidchart.com/blog/waterfall-project-management-methodology ) 

**Requirement gathering and documentation** -
In this stage, you should gather comprehensive information about what this project requires. You can gather this information in a variety of ways, from interviews to questionnaires to interactive brainstorming. By the end of this phase, the project requirements should be clear, and you should have a requirements document that has been distributed to your team.

**System design** -
Using the established requirements, your team designs the system. No coding takes place during this phase, but the team establishes specs such as programming language or hardware requirements.

**Implementation** -
Coding takes place in this phase. Programmers take information from the previous stage and create a functional product. They typically implement code in small pieces, which are integrated at the end of this phase or the beginning of the next.

**Testing** -
Once all coding is done, testing of the product can begin. Testers methodically find and report any problems. If serious issues arise, your project may need to return to phase one for reevaluation.

**Delivery/deployment** -
In this phase, the product is complete, and your team submits the deliverables to be deployed or released.

**Maintenance** -
The product has been delivered to the client and is being used. As issues arise, your team may need to create patches and updates may to address them. Again, big issues may necessitate a return to phase one.

## Benefits of waterfall project 
Although most companies use some combination of project management styles, a 2017 report from LiquidPlanner showed that 25.5% of manufacturing companies currently use waterfall. What makes this methodology successful for so many teams?

**Keeps training simple** -

This methodology could ensure your project’s success even if there are unanticipated changes in bandwidth. Because waterfall project management emphasizes thorough documentation, you can easily and seamlessly add new team members to any project. There’s no need to intuit what an absent programmer was trying to do, as everything—from the project’s conception to its completion—is recorded. New team members can simply refer to documentation to get quickly up to speed.


# V-Model

## Phases  (source: https://www.javatpoint.com/software-engineering-v-model)

 Validation and verification phases

1. **Verification Phases**

**Business Requirement Analysis** - this is the first step where product requirements understood from the customer's side. This phase contains detailed communication to understand customer's expectations and exact requirements.

**System Design** - n this stage system engineers analyze and interpret the business of the proposed system by studying the user requirements document.

**Architectural Design** - The baseline in selecting the architecture is that it should understand all which typically consists of the list of modules, brief functionality of each module, their interface relationships, dependencies, database tables, architecture diagrams, technology detail, etc. The integration testing model is carried out in a particular phase.

**Module Design** - in the module design phase, the system breaks down into small modules. The detailed design of the modules is specified, which is known as Low-Level Design

**Coding Phase** - After designing, the coding phase is started. Based on the requirements, a suitable programming language is decided. There are some guidelines and standards for coding. Before checking in the repository, the final build is optimized for better performance, and the code goes through many code reviews to check the performance.

2. **There are the various phases of Validation Phase of V-model:**

**Unit Testing** - n the V-Model, Unit Test Plans (UTPs) are developed during the module design phase. These UTPs are executed to eliminate errors at code level or unit level. A unit is the smallest entity which can independently exist, e.g., a program module. Unit testing verifies that the smallest entity can function correctly when isolated from the rest of the codes/ units.

**Integration Testing** - Integration Test Plans are developed during the Architectural Design Phase. These tests verify that groups created and tested independently can coexist and communicate among themselves.

**System Testing** - System Tests Plans are developed during System Design Phase. Unlike Unit and Integration Test Plans, System Tests Plans are composed by the client?s business team. System Test ensures that expectations from an application developer are met.

**Acceptance Testing** - Acceptance testing is associated with the business requirement analysis phase and involves testing the product in user environment. Acceptance tests uncover the compatibility issues with the other systems available in the user environment. It also discovers the non-functional issues such as load and performance defects in the actual user environment.

## The difference between waterfall and V model 

The main difference between waterfall model and V model is that in waterfall model, the testing activities are carried out after the development activities are over. On the other hand in V model, testing activities start with the first stage itself. In other words, waterfall model is a continuous process, while the V model is a simultaneous process. 

## Agile

a) **Size of the developer team**: Small

b) **Complexity of the project**: Simple

c) **Known requirements**: Not too important

d) **Change of requirements**: Possible and easy

e) **Time To Market**: Really fast

f) **Knowledge of IT (customer)**: High

g) **Average number of iteration**: More than one

## Waterfall

a) **Size of the developer team**: Medium

b) **Complexity of the project**: Simple

c) **Known requirements**: Yes

d) **Change of requirements**: Not possible

e) **Time To Market**: Moderate

f) **Knowledge of IT (customer)**: Very little

g) **Average number of iteration**: One

## V-Model

a) **Size of the developer team**: Large

b) **Complexity of the project**: Complex

c) **Known requirements**: Yes

d) **Change of requirements**: Yes

e) **Time To Market**: Slow

f) **Knowledge of IT (customer)**: No

g) **Average number of iteration**: One
